#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol

try:
    from thrift.protocol import fastbinary
except:
    fastbinary = None


class ThType:
    """
  Attributes:
   - name
   - min_value
   - max_value
   - format_of_value
   - size
   - description
   - id
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None),  # 1
        (2, TType.STRING, "min_value", None, None),  # 2
        (3, TType.STRING, "max_value", None, None),  # 3
        (4, TType.STRING, "format_of_value", None, None),  # 4
        (5, TType.I32, "size", None, None),  # 5
        (6, TType.STRING, "description", None, None),  # 6
        (7, TType.I32, "id", None, None),  # 7
    )

    def __init__(
        self,
        name=None,
        min_value=None,
        max_value=None,
        format_of_value=None,
        size=None,
        description=None,
        id=None,
    ):
        self.name = name
        self.min_value = min_value
        self.max_value = max_value
        self.format_of_value = format_of_value
        self.size = size
        self.description = description
        self.id = id

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.min_value = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.max_value = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.format_of_value = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.description = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("ThType")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.min_value is not None:
            oprot.writeFieldBegin("min_value", TType.STRING, 2)
            oprot.writeString(self.min_value)
            oprot.writeFieldEnd()
        if self.max_value is not None:
            oprot.writeFieldBegin("max_value", TType.STRING, 3)
            oprot.writeString(self.max_value)
            oprot.writeFieldEnd()
        if self.format_of_value is not None:
            oprot.writeFieldBegin("format_of_value", TType.STRING, 4)
            oprot.writeString(self.format_of_value)
            oprot.writeFieldEnd()
        if self.size is not None:
            oprot.writeFieldBegin("size", TType.I32, 5)
            oprot.writeI32(self.size)
            oprot.writeFieldEnd()
        if self.description is not None:
            oprot.writeFieldBegin("description", TType.STRING, 6)
            oprot.writeString(self.description)
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin("id", TType.I32, 7)
            oprot.writeI32(self.id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ThMathOperation:
    """
  Attributes:
   - name
   - type_of_argument
   - type_of_value
   - description
   - id
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None),  # 1
        (2, TType.STRING, "type_of_argument", None, None),  # 2
        (3, TType.STRING, "type_of_value", None, None),  # 3
        (4, TType.STRING, "description", None, None),  # 4
        (5, TType.I32, "id", None, None),  # 5
    )

    def __init__(
        self,
        name=None,
        type_of_argument=None,
        type_of_value=None,
        description=None,
        id=None,
    ):
        self.name = name
        self.type_of_argument = type_of_argument
        self.type_of_value = type_of_value
        self.description = description
        self.id = id

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.type_of_argument = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.type_of_value = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.description = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("ThMathOperation")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.type_of_argument is not None:
            oprot.writeFieldBegin("type_of_argument", TType.STRING, 2)
            oprot.writeString(self.type_of_argument)
            oprot.writeFieldEnd()
        if self.type_of_value is not None:
            oprot.writeFieldBegin("type_of_value", TType.STRING, 3)
            oprot.writeString(self.type_of_value)
            oprot.writeFieldEnd()
        if self.description is not None:
            oprot.writeFieldBegin("description", TType.STRING, 4)
            oprot.writeString(self.description)
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin("id", TType.I32, 5)
            oprot.writeI32(self.id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ThClass:
    """
  Attributes:
   - name
   - num_of_methods
   - num_of_fields
   - id
  """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, "name", None, None),  # 1
        (2, TType.I32, "num_of_methods", None, None),  # 2
        (3, TType.I32, "num_of_fields", None, None),  # 3
        (4, TType.I32, "id", None, None),  # 4
    )

    def __init__(self, name=None, num_of_methods=None, num_of_fields=None, id=None):
        self.name = name
        self.num_of_methods = num_of_methods
        self.num_of_fields = num_of_fields
        self.id = id

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.num_of_methods = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.num_of_fields = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("ThClass")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.num_of_methods is not None:
            oprot.writeFieldBegin("num_of_methods", TType.I32, 2)
            oprot.writeI32(self.num_of_methods)
            oprot.writeFieldEnd()
        if self.num_of_fields is not None:
            oprot.writeFieldBegin("num_of_fields", TType.I32, 3)
            oprot.writeI32(self.num_of_fields)
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin("id", TType.I32, 4)
            oprot.writeI32(self.id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InvalidID(TException):
    """
  Attributes:
   - id
   - why
  """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, "id", None, None),  # 1
        (2, TType.STRING, "why", None, None),  # 2
    )

    def __init__(self, id=None, why=None):
        self.id = id
        self.why = why

    def read(self, iprot):
        if (
            iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            fastbinary.decode_binary(
                self, iprot.trans, (self.__class__, self.thrift_spec)
            )
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.why = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if (
            oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated
            and self.thrift_spec is not None
            and fastbinary is not None
        ):
            oprot.trans.write(
                fastbinary.encode_binary(self, (self.__class__, self.thrift_spec))
            )
            return
        oprot.writeStructBegin("InvalidID")
        if self.id is not None:
            oprot.writeFieldBegin("id", TType.I32, 1)
            oprot.writeI32(self.id)
            oprot.writeFieldEnd()
        if self.why is not None:
            oprot.writeFieldBegin("why", TType.STRING, 2)
            oprot.writeString(self.why)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

